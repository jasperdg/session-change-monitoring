<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Sessions Monitor - SEDA API</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@3.0.0/index.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .controls {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 15px;
        }

        .day-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .day-selector label {
            font-weight: 600;
            color: #374151;
        }

        .day-selector select {
            padding: 8px 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 0.95rem;
            background: white;
            color: #374151;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .day-selector select:hover {
            border-color: #6366f1;
        }

        .day-selector select:focus {
            outline: none;
            border-color: #6366f1;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #10b981;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            background-color: #6366f1;
            color: white;
        }

        button:hover {
            background-color: #4f46e5;
            transform: translateY(-2px);
        }

        .loading {
            text-align: center;
            color: white;
            font-size: 1.2rem;
            padding: 40px;
        }

        .day-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .day-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e5e7eb;
        }

        .day-title {
            font-size: 1.8rem;
            color: #1f2937;
            font-weight: bold;
        }

        .day-date {
            font-size: 1rem;
            color: #6b7280;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }

        .chart-container {
            background: #f9fafb;
            border-radius: 10px;
            padding: 20px;
            min-height: 300px;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .chart-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #374151;
        }

        .chart-time {
            font-size: 0.9rem;
            color: #6b7280;
        }

        .chart-stats {
            display: flex;
            gap: 15px;
            font-size: 0.85rem;
            color: #6b7280;
        }

        .full-day-chart {
            grid-column: 1 / -1;
        }

        .no-data {
            text-align: center;
            color: #9ca3af;
            padding: 40px;
            font-style: italic;
        }

        .error-message {
            background: #fee;
            border-left: 4px solid #ef4444;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            color: #991b1b;
        }

        canvas {
            max-height: 250px;
        }

        .full-day-chart canvas {
            max-height: 400px;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            font-size: 0.85rem;
            color: #6b7280;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        /* Data viewer modal */
        .data-viewer-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            overflow: auto;
            padding: 20px;
        }

        .data-viewer-modal.show {
            display: block;
        }

        .data-viewer-content {
            background: white;
            border-radius: 15px;
            max-width: 1400px;
            margin: 0 auto;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .data-viewer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e5e7eb;
        }

        .data-viewer-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1f2937;
        }

        .data-viewer-close {
            background: #ef4444;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        .data-viewer-close:hover {
            background: #dc2626;
        }

        .data-viewer-info {
            background: #f3f4f6;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 0.9rem;
            color: #374151;
        }

        .data-table-container {
            overflow-x: auto;
            max-height: 60vh;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        .data-table th {
            background: #667eea;
            color: white;
            padding: 12px 10px;
            text-align: left;
            position: sticky;
            top: 0;
            z-index: 10;
            font-weight: 600;
        }

        .data-table td {
            padding: 10px;
            border-bottom: 1px solid #e5e7eb;
        }

        .data-table tbody tr {
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .data-table tr:hover {
            background: #f9fafb;
        }

        .data-table tr.selected {
            background: #dbeafe !important;
            border-left: 3px solid #3b82f6;
        }

        .data-table td.timestamp {
            white-space: nowrap;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
        }

        .data-table td.rate {
            font-weight: 600;
            color: #667eea;
        }

        .export-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn-export {
            background: #10b981;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        .btn-export:hover {
            background: #059669;
        }

        .zoom-instruction {
            text-align: center;
            font-size: 0.85rem;
            color: #6b7280;
            margin-top: 5px;
            font-style: italic;
        }

        .raw-data-section {
            margin-top: 20px;
            padding: 15px;
            background: #f9fafb;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .raw-data-header {
            font-weight: 600;
            margin-bottom: 10px;
            color: #374151;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .raw-data-content {
            background: #1f2937;
            color: #e5e7eb;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            overflow-x: auto;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .raw-data-empty {
            color: #6b7280;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }

        .btn-copy-raw {
            background: #6b7280;
            color: white;
            border: none;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .btn-copy-raw:hover {
            background: #4b5563;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìä Trading Session Transitions Monitor</h1>
            <p>4-Minute Transition Windows - SEDA API Data</p>
        </div>

        <div class="controls">
            <div class="status">
                <div class="status-indicator"></div>
                <span id="statusText">Select a day to view data...</span>
            </div>
            <div class="day-selector">
                <label for="daySelector">Select Day:</label>
                <select id="daySelector" onchange="loadSelectedDay()">
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>
            <button onclick="loadSelectedDay()">üîÑ Reload</button>
        </div>

        <div id="errorContainer"></div>
        <div id="loadingContainer" class="loading">Loading trading session data...</div>
        <div id="chartsContainer"></div>
    </div>

    <!-- Data Viewer Modal -->
    <div id="dataViewerModal" class="data-viewer-modal">
        <div class="data-viewer-content">
            <div class="data-viewer-header">
                <div class="data-viewer-title">üìä Selected Timeframe Data</div>
                <button class="data-viewer-close" onclick="closeDataViewer()">‚úï Close</button>
            </div>
            <div class="data-viewer-info" id="dataViewerInfo"></div>
            <div class="data-table-container">
                <table class="data-table" id="dataTable">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Timestamp (Local)</th>
                            <th>Timestamp (UTC)</th>
                            <th>Composite Rate</th>
                            <th>Active Session</th>
                            <th>Session Weight</th>
                            <th>Reference Weight</th>
                        </tr>
                    </thead>
                    <tbody id="dataTableBody"></tbody>
                </table>
            </div>
            <div class="raw-data-section">
                <div class="raw-data-header">
                    <span>üìù Raw API Response & Database Entry</span>
                    <button class="btn-copy-raw" onclick="copyRawData()" style="display: none;" id="btnCopyRaw">üìã Copy JSON</button>
                </div>
                <div id="rawDataContent" class="raw-data-content" style="display: none;"></div>
                <div id="rawDataEmpty" class="raw-data-empty">Click on a row above to view the complete raw API response and database entry</div>
            </div>
            <div class="export-buttons">
                <button class="btn-export" onclick="exportToCSV()">üì• Export to CSV</button>
                <button class="btn-export" onclick="exportToJSON()">üì• Export to JSON</button>
            </div>
        </div>
    </div>

    <script>
        const TRADING_SESSIONS = {
            overnight: { name: 'Overnight - Premarket', startTime: '03:58', endTime: '04:02', color: '#8b5cf6' },
            premarket: { name: 'Premarket - Regular Hours', startTime: '09:28', endTime: '09:32', color: '#ec4899' },
            regular: { name: 'Regular Hours - After Hours', startTime: '15:58', endTime: '16:02', color: '#10b981' },
            afterhours: { name: 'After Hours - Overnight', startTime: '19:58', endTime: '20:02', color: '#f59e0b' }
        };

        const charts = [];
        let currentViewerData = []; // Store data for export
        let selectedRawData = null; // Store selected record for raw view
        let selectedTable = null; // Current selected table (set from URL or dropdown)

        function showError(message) {
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.innerHTML = `
                <div class="error-message">
                    <strong>‚ö†Ô∏è Error:</strong> ${message}
                </div>
            `;
        }

        function hideError() {
            document.getElementById('errorContainer').innerHTML = '';
        }

        function updateStatus(message) {
            document.getElementById('statusText').textContent = message;
        }

        // Convert ET time to UTC for API query
        function getUTCDateTimeForET(date, etTime) {
            const [hours, minutes] = etTime.split(':').map(Number);
            
            // Get date components (date is in UTC from our selector)
            const year = date.getUTCFullYear();
            const month = date.getUTCMonth();
            const day = date.getUTCDate();
            
            // Determine ET offset by testing what hour it is in ET when it's 12:00 UTC
            const testDate = new Date(Date.UTC(year, month, day, 12, 0, 0));
            const etHourString = testDate.toLocaleString('en-US', {
                timeZone: 'America/New_York',
                hour12: false,
                hour: '2-digit',
                minute: '2-digit'
            });
            
            const etHour = parseInt(etHourString.split(':')[0]);
            
            // In EST (winter): UTC 12:00 = 07:00 ET (offset 5)
            // In EDT (summer): UTC 12:00 = 08:00 ET (offset 4)
            const etOffset = (12 - etHour);
            
            console.log(`Date ${year}-${String(month+1).padStart(2,'0')}-${String(day).padStart(2,'0')} ${etTime} ET: UTC 12:00 = ${etHourString} ET, offset = ${etOffset}`);
            
            // Create UTC timestamp: add ET offset hours
            const utcDate = new Date(Date.UTC(year, month, day, hours + etOffset, minutes, 0));
            
            console.log(`  Result: ${etTime} ET = ${utcDate.toISOString()}`);
            
            return utcDate.toISOString();
        }

        // Get session time range for a specific day
        function getSessionTimeRange(date, session) {
            const sessionInfo = TRADING_SESSIONS[session];
            let startDateTime, endDateTime;

            // All sessions now occur on the same day
            startDateTime = getUTCDateTimeForET(date, sessionInfo.startTime);
            endDateTime = getUTCDateTimeForET(date, sessionInfo.endTime);

            return { start: startDateTime, end: endDateTime };
        }

        // Fetch data for a specific time range
        async function fetchSessionData(start, end) {
            try {
                const url = `/api/history?start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}&limit=10000&table=${encodeURIComponent(selectedTable)}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                return data.data || [];
            } catch (error) {
                console.error('Error fetching session data:', error);
                return [];
            }
        }

        // Handle asset/table selection change
        function onAssetChange() {
            selectedTable = document.getElementById('assetSelector').value;
            console.log('Selected table changed to:', selectedTable);
            loadSelectedDay(); // Reload data with new table
        }

        // Populate asset selector with available tables (can be called after detecting tables)
        function populateAssetSelector(tables) {
            const selector = document.getElementById('assetSelector');
            selector.innerHTML = '';
            
            tables.forEach(table => {
                const option = document.createElement('option');
                option.value = table;
                option.textContent = table;
                selector.appendChild(option);
            });
            
            // Set first table as selected
            if (tables.length > 0) {
                selectedTable = tables[0];
            }
        }

        // Create a chart for a session
        function createSessionChart(containerId, sessionName, sessionTime, data, color) {
            const canvas = document.getElementById(containerId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            
            // Data comes from API in DESC order (newest first), reverse to show oldest ‚Üí newest
            const sortedData = [...data].reverse();
            
            // Store original timestamps for tooltip
            const timestamps = sortedData.map(d => d.timestamp);
            
            const labels = sortedData.map(d => {
                const date = new Date(d.timestamp);
                return date.toLocaleTimeString('en-US', { 
                    hour: '2-digit', 
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false 
                });
            });
            
            const values = sortedData.map(d => parseFloat(d.composite_rate));

            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: sessionName,
                        data: values,
                        borderColor: color,
                        backgroundColor: `${color}20`,
                        borderWidth: 2,
                        tension: 0.4,
                        fill: true,
                        pointRadius: 2,
                        pointBackgroundColor: color,
                        pointBorderColor: '#fff',
                        pointBorderWidth: 1,
                        pointHoverRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    animation: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 10,
                            titleFont: { size: 12 },
                            bodyFont: { size: 12 },
                            callbacks: {
                                title: function(context) {
                                    // Get the original timestamp from the data
                                    const dataIndex = context[0].dataIndex;
                                    if (dataIndex < timestamps.length) {
                                        const timestamp = timestamps[dataIndex];
                                        const date = new Date(timestamp);
                                        
                                        // Format in ET timezone
                                        const etTime = date.toLocaleString('en-US', {
                                            timeZone: 'America/New_York',
                                            year: 'numeric',
                                            month: 'short',
                                            day: 'numeric',
                                            hour: '2-digit',
                                            minute: '2-digit',
                                            second: '2-digit',
                                            hour12: true
                                        });
                                        
                                        return `${etTime} ET`;
                                    }
                                    return context[0].label;
                                },
                                label: function(context) {
                                    return `Rate: ${parseFloat(context.parsed.y).toFixed(5)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: {
                                font: { size: 10 },
                                callback: function(value) {
                                    return value.toFixed(2);
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        x: {
                            ticks: {
                                font: { size: 9 },
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 8
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });

            charts.push(chart);
            
            // Add double-click handler to view detailed data
            canvas.addEventListener('dblclick', async (event) => {
                // Use sortedData which is in ascending order (oldest to newest)
                if (sortedData.length === 0) {
                    showError('No data available in this chart');
                    return;
                }
                
                // Get the clicked point index from Chart.js
                const points = chart.getElementsAtEventForMode(event, 'nearest', { intersect: true }, false);
                
                let clickedIndex = -1;
                if (points.length > 0) {
                    clickedIndex = points[0].index;
                } else {
                    // If no exact point, get nearest point
                    const nearestPoints = chart.getElementsAtEventForMode(event, 'index', { intersect: false }, false);
                    if (nearestPoints.length > 0) {
                        clickedIndex = nearestPoints[0].index;
                    }
                }
                
                if (clickedIndex === -1 || clickedIndex >= sortedData.length) {
                    showError('Could not determine clicked data point');
                    return;
                }
                
                // Get 5 points before and 5 points after (11 total)
                const startIndex = Math.max(0, clickedIndex - 5);
                const endIndex = Math.min(sortedData.length - 1, clickedIndex + 5);
                
                const startTime = sortedData[startIndex].timestamp;
                const endTime = sortedData[endIndex].timestamp;
                
                console.log('Session chart clicked:', {
                    sessionName,
                    totalPoints: sortedData.length,
                    clickedIndex,
                    rangeIndices: { start: startIndex, end: endIndex },
                    rangeSize: endIndex - startIndex + 1,
                    clickedPoint: sortedData[clickedIndex],
                    timeRange: {
                        start: new Date(startTime).toISOString(),
                        end: new Date(endTime).toISOString()
                    }
                });
                
                await showDetailedDataViewer(startTime, endTime, `${sessionName} (¬±5 points)`);
            });
            
            return chart;
        }

        // Get statistics for data
        function getDataStats(data) {
            if (!data || data.length === 0) {
                return { count: 0, min: 0, max: 0, avg: 0 };
            }

            const values = data.map(d => parseFloat(d.composite_rate));
            const min = Math.min(...values);
            const max = Math.max(...values);
            const avg = values.reduce((a, b) => a + b, 0) / values.length;

            return {
                count: data.length,
                min: min.toFixed(5),
                max: max.toFixed(5),
                avg: avg.toFixed(5)
            };
        }

        // Create full day chart
        function createFullDayChart(containerId, date, allSessionsData) {
            const canvas = document.getElementById(containerId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            
            // Combine all session data and sort by timestamp (ascending: oldest ‚Üí newest)
            const allData = [];
            Object.keys(allSessionsData).forEach(session => {
                allSessionsData[session].forEach(d => {
                    allData.push({
                        ...d,
                        session: session
                    });
                });
            });
            
            // Sort ascending: oldest first (left) to newest last (right)
            allData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            // Store original timestamps for tooltip
            const timestamps = allData.map(d => d.timestamp);

            const labels = allData.map(d => {
                const date = new Date(d.timestamp);
                return date.toLocaleTimeString('en-US', { 
                    hour: '2-digit', 
                    minute: '2-digit',
                    hour12: false 
                });
            });
            
            const values = allData.map(d => parseFloat(d.composite_rate));

            // Color points by session
            const pointColors = allData.map(d => TRADING_SESSIONS[d.session].color);

            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'All Transition Periods',
                        data: values,
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        tension: 0.4,
                        fill: true,
                        pointRadius: 3,
                        pointBackgroundColor: pointColors,
                        pointBorderColor: '#fff',
                        pointBorderWidth: 1,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    animation: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            titleFont: { size: 13 },
                            bodyFont: { size: 13 },
                            callbacks: {
                                title: function(context) {
                                    // Get the original timestamp from the data
                                    const dataIndex = context[0].dataIndex;
                                    if (dataIndex < timestamps.length) {
                                        const timestamp = timestamps[dataIndex];
                                        const date = new Date(timestamp);
                                        
                                        // Format in ET timezone
                                        const etTime = date.toLocaleString('en-US', {
                                            timeZone: 'America/New_York',
                                            year: 'numeric',
                                            month: 'short',
                                            day: 'numeric',
                                            hour: '2-digit',
                                            minute: '2-digit',
                                            second: '2-digit',
                                            hour12: true
                                        });
                                        
                                        return `${etTime} ET`;
                                    }
                                    return context[0].label;
                                },
                                label: function(context) {
                                    const datasetLabel = context.dataset.label || '';
                                    return `${datasetLabel}: ${parseFloat(context.parsed.y).toFixed(5)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: {
                                font: { size: 11 },
                                callback: function(value) {
                                    return value.toFixed(2);
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        x: {
                            ticks: {
                                font: { size: 10 },
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 15
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });

            charts.push(chart);
            
            // Add double-click handler to view detailed data for combined chart
            canvas.addEventListener('dblclick', async (event) => {
                // Use allData which is already sorted ascending (oldest to newest)
                if (allData.length === 0) {
                    showError('No data available in combined chart');
                    return;
                }
                
                // Get the clicked point index from Chart.js
                const points = chart.getElementsAtEventForMode(event, 'nearest', { intersect: true }, false);
                
                let clickedIndex = -1;
                if (points.length > 0) {
                    clickedIndex = points[0].index;
                } else {
                    // If no exact point, get nearest point
                    const nearestPoints = chart.getElementsAtEventForMode(event, 'index', { intersect: false }, false);
                    if (nearestPoints.length > 0) {
                        clickedIndex = nearestPoints[0].index;
                    }
                }
                
                if (clickedIndex === -1 || clickedIndex >= allData.length) {
                    showError('Could not determine clicked data point');
                    return;
                }
                
                // Get 5 points before and 5 points after (11 total)
                const startIndex = Math.max(0, clickedIndex - 5);
                const endIndex = Math.min(allData.length - 1, clickedIndex + 5);
                
                const startTime = allData[startIndex].timestamp;
                const endTime = allData[endIndex].timestamp;
                
                console.log('Combined chart clicked:', {
                    totalPoints: allData.length,
                    clickedIndex,
                    rangeIndices: { start: startIndex, end: endIndex },
                    rangeSize: endIndex - startIndex + 1,
                    clickedPoint: allData[clickedIndex],
                    timeRange: {
                        start: new Date(startTime).toISOString(),
                        end: new Date(endTime).toISOString()
                    }
                });
                
                await showDetailedDataViewer(startTime, endTime, 'Combined Sessions (¬±5 points)');
            });
            
            return chart;
        }

        // Show data viewer for a time range
        async function showDetailedDataViewer(startTime, endTime, sessionName = '') {
            try {
                updateStatus('Fetching detailed data...');
                
                // Debug logging
                console.log('Data Viewer Query:', {
                    sessionName,
                    startTime,
                    endTime,
                    startDate: new Date(startTime).toISOString(),
                    endDate: new Date(endTime).toISOString()
                });
                
                const url = `/api/history?start=${encodeURIComponent(startTime)}&end=${encodeURIComponent(endTime)}&limit=10000&table=${encodeURIComponent(selectedTable)}`;
                console.log('API URL:', url);
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                console.log('API Response:', { recordCount: result.data?.length || 0 });
                
                if (!result.data || result.data.length === 0) {
                    showError(`No detailed data found for this time range.<br>
                        Start: ${new Date(startTime).toLocaleString()}<br>
                        End: ${new Date(endTime).toLocaleString()}<br>
                        <small>Check console for API query details.</small>`);
                    return;
                }

                // Reverse to show oldest first
                const data = result.data.reverse();
                currentViewerData = data;
                
                // Populate info
                const infoDiv = document.getElementById('dataViewerInfo');
                const startDate = new Date(startTime);
                const endDate = new Date(endTime);
                infoDiv.innerHTML = `
                    <strong>Session:</strong> ${sessionName || 'Combined'}<br>
                    <strong>Time Range:</strong> ${startDate.toLocaleString()} - ${endDate.toLocaleString()}<br>
                    <strong>Records Found:</strong> ${data.length}<br>
                    <strong>Duration:</strong> ${((endDate - startDate) / 1000 / 60).toFixed(2)} minutes
                `;
                
                // Populate table
                const tbody = document.getElementById('dataTableBody');
                tbody.innerHTML = '';
                
                data.forEach((record, index) => {
                    const row = tbody.insertRow();
                    const localTime = new Date(record.timestamp);
                    
                    row.innerHTML = `
                        <td>${record.id}</td>
                        <td class="timestamp">${localTime.toLocaleString()}</td>
                        <td class="timestamp">${record.timestamp}</td>
                        <td class="rate">${parseFloat(record.composite_rate).toFixed(5)}</td>
                        <td>${record.active_session || 'N/A'}</td>
                        <td>${record.session_weight || 'N/A'}</td>
                        <td>${record.reference_weight || 'N/A'}</td>
                    `;
                    
                    // Add click handler to show raw data
                    row.addEventListener('click', function() {
                        // Remove previous selection
                        const previousSelected = tbody.querySelector('tr.selected');
                        if (previousSelected) {
                            previousSelected.classList.remove('selected');
                        }
                        
                        // Select this row
                        this.classList.add('selected');
                        
                        // Show raw data
                        showRawData(record);
                    });
                });
                
                // Clear raw data section
                clearRawData();
                
                // Show modal
                document.getElementById('dataViewerModal').classList.add('show');
                updateStatus(`Loaded ${data.length} detailed records`);
                
            } catch (error) {
                console.error('Error loading detailed data:', error);
                showError(`Failed to load detailed data: ${error.message}`);
            }
        }

        // Close data viewer
        function closeDataViewer() {
            document.getElementById('dataViewerModal').classList.remove('show');
            clearRawData();
        }

        // Show raw data for selected record
        function showRawData(record) {
            selectedRawData = record;
            
            const rawDataContent = document.getElementById('rawDataContent');
            const rawDataEmpty = document.getElementById('rawDataEmpty');
            const btnCopyRaw = document.getElementById('btnCopyRaw');
            
            // Parse raw_data if it exists (it's stored as JSON string in database)
            let displayData = { ...record };
            if (record.raw_data) {
                try {
                    // If raw_data is a string, parse it
                    if (typeof record.raw_data === 'string') {
                        displayData.raw_data = JSON.parse(record.raw_data);
                    }
                } catch (e) {
                    console.warn('Could not parse raw_data:', e);
                }
            }
            
            // Create formatted display with raw_data highlighted
            let formattedDisplay = '';
            
            if (displayData.raw_data) {
                formattedDisplay = `// ============================================\n`;
                formattedDisplay += `// RAW API RESPONSE DATA\n`;
                formattedDisplay += `// ============================================\n\n`;
                formattedDisplay += JSON.stringify(displayData.raw_data, null, 2);
                formattedDisplay += `\n\n// ============================================\n`;
                formattedDisplay += `// COMPLETE DATABASE RECORD\n`;
                formattedDisplay += `// ============================================\n\n`;
                formattedDisplay += JSON.stringify(displayData, null, 2);
            } else {
                formattedDisplay = JSON.stringify(displayData, null, 2);
            }
            
            rawDataContent.textContent = formattedDisplay;
            rawDataContent.style.display = 'block';
            rawDataEmpty.style.display = 'none';
            btnCopyRaw.style.display = 'inline-block';
            
            // Scroll to raw data section
            rawDataContent.parentElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        // Clear raw data display
        function clearRawData() {
            selectedRawData = null;
            
            const rawDataContent = document.getElementById('rawDataContent');
            const rawDataEmpty = document.getElementById('rawDataEmpty');
            const btnCopyRaw = document.getElementById('btnCopyRaw');
            
            rawDataContent.style.display = 'none';
            rawDataContent.textContent = '';
            rawDataEmpty.style.display = 'block';
            btnCopyRaw.style.display = 'none';
        }

        // Copy raw data to clipboard
        function copyRawData() {
            if (!selectedRawData) return;
            
            // Parse and format raw_data if it exists
            let dataToCopy = { ...selectedRawData };
            if (dataToCopy.raw_data && typeof dataToCopy.raw_data === 'string') {
                try {
                    dataToCopy.raw_data = JSON.parse(dataToCopy.raw_data);
                } catch (e) {
                    console.warn('Could not parse raw_data for copy:', e);
                }
            }
            
            const jsonString = JSON.stringify(dataToCopy, null, 2);
            
            navigator.clipboard.writeText(jsonString).then(() => {
                const btn = document.getElementById('btnCopyRaw');
                const originalText = btn.textContent;
                btn.textContent = '‚úì Copied!';
                btn.style.background = '#10b981';
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#6b7280';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                showError('Failed to copy to clipboard');
            });
        }

        // Close modal when clicking outside
        document.getElementById('dataViewerModal').addEventListener('click', (e) => {
            if (e.target.id === 'dataViewerModal') {
                closeDataViewer();
            }
        });

        // Export to CSV
        function exportToCSV() {
            if (currentViewerData.length === 0) return;
            
            const headers = ['ID', 'Timestamp (UTC)', 'Timestamp (Local)', 'Composite Rate', 'Active Session', 'Session Weight', 'Reference Weight'];
            const csvContent = [
                headers.join(','),
                ...currentViewerData.map(record => {
                    const localTime = new Date(record.timestamp).toLocaleString();
                    return [
                        record.id,
                        `"${record.timestamp}"`,
                        `"${localTime}"`,
                        record.composite_rate,
                        record.active_session || '',
                        record.session_weight || '',
                        record.reference_weight || ''
                    ].join(',');
                })
            ].join('\n');
            
            downloadFile(csvContent, 'session-data.csv', 'text/csv');
        }

        // Export to JSON
        function exportToJSON() {
            if (currentViewerData.length === 0) return;
            
            const jsonContent = JSON.stringify(currentViewerData, null, 2);
            downloadFile(jsonContent, 'session-data.json', 'application/json');
        }

        // Helper to download file
        function downloadFile(content, filename, contentType) {
            const blob = new Blob([content], { type: contentType });
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            window.URL.revokeObjectURL(url);
        }

        // Load data for a specific day
        async function loadDayData(date, dayIndex) {
            const dayStr = date.toLocaleDateString('en-US', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });

            const dayId = `day-${dayIndex}`;
            const allSessionsData = {};

            // Fetch data for each session
            for (const [sessionKey, sessionInfo] of Object.entries(TRADING_SESSIONS)) {
                const timeRange = getSessionTimeRange(date, sessionKey);
                const data = await fetchSessionData(timeRange.start, timeRange.end);
                allSessionsData[sessionKey] = data;
            }

            // Create HTML for this day
            let html = `
                <div class="day-section" id="${dayId}">
                    <div class="day-header">
                        <div>
                            <div class="day-title">${dayStr}</div>
                            <div class="day-date">${date.toISOString().split('T')[0]}</div>
                        </div>
                    </div>
                    <div class="charts-grid">
            `;

            // Add session charts
            for (const [sessionKey, sessionInfo] of Object.entries(TRADING_SESSIONS)) {
                const data = allSessionsData[sessionKey];
                const stats = getDataStats(data);
                const canvasId = `chart-${dayIndex}-${sessionKey}`;
                
                html += `
                    <div class="chart-container">
                        <div class="chart-header">
                            <div class="chart-title">${sessionInfo.name}</div>
                            <div class="chart-time">${sessionInfo.startTime} - ${sessionInfo.endTime} ET</div>
                        </div>
                        ${data.length > 0 ? `
                            <canvas id="${canvasId}"></canvas>
                            <div class="chart-stats">
                                <span>Points: ${stats.count}</span>
                                <span>Min: ${stats.min}</span>
                                <span>Max: ${stats.max}</span>
                                <span>Avg: ${stats.avg}</span>
                            </div>
                            <div class="zoom-instruction">
                                üí° Drag to zoom | Double-click a point to view ¬±5 records
                            </div>
                        ` : '<div class="no-data">No data available for this session</div>'}
                    </div>
                `;
            }

            // Add combined transitions chart
            const totalPoints = Object.values(allSessionsData).reduce((sum, data) => sum + data.length, 0);
            const fullDayCanvasId = `chart-${dayIndex}-fullday`;
            
            html += `
                <div class="chart-container full-day-chart">
                    <div class="chart-header">
                        <div class="chart-title">All Transition Periods Combined</div>
                        <div class="chart-time">4 √ó 4-minute windows (16 minutes total data)</div>
                    </div>
                    ${totalPoints > 0 ? `
                        <canvas id="${fullDayCanvasId}"></canvas>
                        <div class="legend">
                            ${Object.entries(TRADING_SESSIONS).map(([key, info]) => `
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: ${info.color}"></div>
                                    <span>${info.name}</span>
                                </div>
                            `).join('')}
                        </div>
                        <div style="text-align: center; margin-top: 10px; font-size: 0.85rem; color: #6b7280; font-style: italic;">
                            ‚ö†Ô∏è Note: This shows only transition periods, not continuous trading data
                        </div>
                        <div class="zoom-instruction">
                            üí° Double-click a point to view ¬±5 surrounding records
                        </div>
                    ` : '<div class="no-data">No data available for this day</div>'}
                </div>
            `;

            html += `
                    </div>
                </div>
            `;

            return { html, allSessionsData, dayIndex };
        }

        // Populate day selector dropdown
        function populateDaySelector() {
            const select = document.getElementById('daySelector');
            const now = new Date();
            
            // Get current date in ET timezone
            const etDateString = now.toLocaleString('en-US', {
                timeZone: 'America/New_York',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            });
            const [etMonth, etDay, etYear] = etDateString.split(/[/,\s]+/).map(s => s.trim());
            const todayET = new Date(Date.UTC(
                parseInt(etYear),
                parseInt(etMonth) - 1,
                parseInt(etDay),
                0, 0, 0, 0
            ));
            
            for (let i = 0; i < 7; i++) {
                const date = new Date(todayET);
                date.setUTCDate(date.getUTCDate() - i);
                
                const option = document.createElement('option');
                option.value = i;
                
                const dateStr = date.toLocaleDateString('en-US', { 
                    timeZone: 'UTC',
                    weekday: 'long', 
                    month: 'short', 
                    day: 'numeric',
                    year: 'numeric'
                });
                
                if (i === 0) {
                    option.text = `Today - ${dateStr}`;
                } else if (i === 1) {
                    option.text = `Yesterday - ${dateStr}`;
                } else {
                    option.text = dateStr;
                }
                
                select.appendChild(option);
            }
        }

        // Load data for the selected day
        async function loadSelectedDay() {
            hideError();
            updateStatus('Loading data...');
            document.getElementById('loadingContainer').style.display = 'block';
            document.getElementById('chartsContainer').innerHTML = '';

            // Destroy existing charts
            charts.forEach(chart => chart.destroy());
            charts.length = 0;

            try {
                const select = document.getElementById('daySelector');
                const daysAgo = parseInt(select.value);
                
                // Get current date in ET timezone
                const now = new Date();
                const etDateString = now.toLocaleString('en-US', {
                    timeZone: 'America/New_York',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit'
                });
                
                // Parse ET date and go back daysAgo days
                const [etMonth, etDay, etYear] = etDateString.split(/[/,\s]+/).map(s => s.trim());
                const selectedDate = new Date(Date.UTC(
                    parseInt(etYear),
                    parseInt(etMonth) - 1,
                    parseInt(etDay),
                    0, 0, 0, 0
                ));
                selectedDate.setUTCDate(selectedDate.getUTCDate() - daysAgo);
                
                updateStatus('Loading trading sessions...');
                const dayData = await loadDayData(selectedDate, 0);

                // Insert HTML
                const chartsContainer = document.getElementById('chartsContainer');
                chartsContainer.innerHTML = dayData.html;

                // Create charts
                const { allSessionsData, dayIndex } = dayData;
                
                // Create session charts
                for (const [sessionKey, sessionInfo] of Object.entries(TRADING_SESSIONS)) {
                    const data = allSessionsData[sessionKey];
                    if (data.length > 0) {
                        const canvasId = `chart-${dayIndex}-${sessionKey}`;
                        createSessionChart(
                            canvasId,
                            sessionInfo.name,
                            `${sessionInfo.startTime} - ${sessionInfo.endTime} ET`,
                            data,
                            sessionInfo.color
                        );
                    }
                }

                // Create full day chart
                const totalPoints = Object.values(allSessionsData).reduce((sum, data) => sum + data.length, 0);
                if (totalPoints > 0) {
                    const fullDayCanvasId = `chart-${dayIndex}-fullday`;
                    createFullDayChart(fullDayCanvasId, selectedDate, allSessionsData);
                }

                document.getElementById('loadingContainer').style.display = 'none';
                
                const dateStr = selectedDate.toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    month: 'long', 
                    day: 'numeric',
                    year: 'numeric'
                });
                updateStatus(`Loaded ${charts.length} charts for ${dateStr}`);
            } catch (error) {
                console.error('Error loading data:', error);
                showError(`Failed to load data: ${error.message}`);
                document.getElementById('loadingContainer').style.display = 'none';
                updateStatus('Error loading data');
            }
        }

        // Load available tables from API
        async function loadAvailableTables() {
            try {
                const response = await fetch('/api/tables');
                if (!response.ok) {
                    console.warn('Could not fetch tables, using default');
                    return;
                }
                
                const result = await response.json();
                if (result.tables && result.tables.length > 0) {
                    populateAssetSelector(result.tables);
                }
            } catch (error) {
                console.warn('Error loading tables:', error);
                // Silently fail and use default table
            }
        }

        // Get table from URL parameter
        function getTableFromURL() {
            const params = new URLSearchParams(window.location.search);
            const tableParam = params.get('table');
            console.log('üîç Table from URL:', tableParam);
            return tableParam;
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', async () => {
            console.log('üì± Page loaded, current URL:', window.location.href);
            
            // Get table from URL
            const tableFromURL = getTableFromURL();
            
            if (!tableFromURL) {
                // No table specified - redirect to landing page
                console.warn('‚ö†Ô∏è No table parameter in URL, redirecting to landing page');
                window.location.href = '/landing.html';
                return;
            }
            
            selectedTable = tableFromURL;
            console.log('‚úÖ Using table:', selectedTable);
            
            // Set it in the dropdown if it exists
            const selector = document.getElementById('assetSelector');
            if (selector) {
                selector.value = selectedTable;
            }
            
            await loadAvailableTables(); // Load available tables for dropdown
            populateDaySelector();
            await loadSelectedDay();
        });
    </script>
</body>
</html>

